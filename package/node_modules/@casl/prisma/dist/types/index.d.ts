import { AbilityOptions, AbilityTuple, PureAbility, RawRuleFrom } from '@casl/ability';
import { Prisma } from '@prisma/client';
import type { PrismaModel, PrismaQueryFactory, PrismaTypes } from './runtime';
export { accessibleBy, ParsingQueryError, prismaQuery } from './runtime';
export type * from './runtime';
export type WhereInput<TModelName extends Prisma.ModelName> = PrismaTypes<Prisma.TypeMap>['WhereInput'][TModelName];
export type PrismaQuery<T extends PrismaModel = PrismaModel> = PrismaQueryFactory<Prisma.TypeMap, T>;
export declare const createPrismaAbility: {
    <T extends PureAbility<any, PrismaQuery<PrismaModel>>>(rules?: (import("@casl/ability/dist/types/types").ToAbilityTypes<T[typeof import("@casl/ability/dist/types/RuleIndex").ɵabilities]> extends infer T_1 ? T_1 extends import("@casl/ability/dist/types/types").ToAbilityTypes<T[typeof import("@casl/ability/dist/types/RuleIndex").ɵabilities]> ? T_1 extends import("@casl/ability/dist/types/types").AbilityTupleType ? import("@casl/ability").SubjectRawRule<T_1[0], T_1[1], T[typeof import("@casl/ability/dist/types/RuleIndex").ɵconditions]> : import("@casl/ability").ClaimRawRule<Extract<import("@casl/ability/dist/types/types").ToAbilityTypes<T[typeof import("@casl/ability/dist/types/RuleIndex").ɵabilities]>, string>> : never : never)[] | undefined, options?: import("@casl/ability").AbilityOptionsOf<T> | undefined): T;
    <A extends AbilityTuple = [string, Prisma.ModelName], C extends PrismaQuery<PrismaModel> = PrismaQuery<PrismaModel>>(rules?: (import("@casl/ability/dist/types/types").ToAbilityTypes<A> extends infer T ? T extends import("@casl/ability/dist/types/types").ToAbilityTypes<A> ? T extends import("@casl/ability/dist/types/types").AbilityTupleType ? import("@casl/ability").SubjectRawRule<T[0], T[1], C> : import("@casl/ability").ClaimRawRule<Extract<import("@casl/ability/dist/types/types").ToAbilityTypes<A>, string>> : never : never)[] | undefined, options?: AbilityOptions<A, C> | undefined): PureAbility<A, C>;
};
/**
 * Uses conditional type to support union distribution
 */
type ExtendedAbilityTuple<T extends AbilityTuple> = T extends AbilityTuple ? [T[0], 'all' | T[1]] : never;
/**
 * @deprecated use createPrismaAbility instead
 */
export declare class PrismaAbility<A extends AbilityTuple = [string, Prisma.ModelName], C extends PrismaQuery = PrismaQuery> extends PureAbility<ExtendedAbilityTuple<A>, C> {
    constructor(rules?: RawRuleFrom<ExtendedAbilityTuple<A>, C>[], options?: AbilityOptions<ExtendedAbilityTuple<A>, C>);
}
