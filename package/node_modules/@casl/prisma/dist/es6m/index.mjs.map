{"version":3,"file":"index.mjs","sources":["../../src/index.ts"],"sourcesContent":["import { AbilityOptions, AbilityTuple, fieldPatternMatcher, PureAbility, RawRuleFrom } from '@casl/ability';\nimport { Prisma } from '@prisma/client';\n\nimport type { PrismaModel, PrismaQueryFactory, PrismaTypes } from './runtime';\nimport { createAbilityFactory, prismaQuery } from './runtime';\n\nexport { accessibleBy, ParsingQueryError, prismaQuery } from './runtime';\nexport type * from './runtime';\nexport type WhereInput<TModelName extends Prisma.ModelName> =\n  PrismaTypes<Prisma.TypeMap>['WhereInput'][TModelName];\nexport type PrismaQuery<T extends PrismaModel = PrismaModel> =\n  PrismaQueryFactory<Prisma.TypeMap, T>;\n\nexport const createPrismaAbility = createAbilityFactory<Prisma.ModelName, PrismaQuery>();\n\n/**\n * Uses conditional type to support union distribution\n */\ntype ExtendedAbilityTuple<T extends AbilityTuple> = T extends AbilityTuple\n  ? [T[0], 'all' | T[1]]\n  : never;\n\n/**\n * @deprecated use createPrismaAbility instead\n */\nexport class PrismaAbility<\n  A extends AbilityTuple = [string, Prisma.ModelName],\n  C extends PrismaQuery = PrismaQuery\n> extends PureAbility<ExtendedAbilityTuple<A>, C> {\n  constructor(\n    rules?: RawRuleFrom<ExtendedAbilityTuple<A>, C>[],\n    options?: AbilityOptions<ExtendedAbilityTuple<A>, C>\n  ) {\n    super(rules, {\n      conditionsMatcher: prismaQuery,\n      fieldMatcher: fieldPatternMatcher,\n      ...options,\n    });\n  }\n}\n"],"names":["createPrismaAbility","createAbilityFactory","PrismaAbility","PureAbility","constructor","rules","options","super","Object","assign","conditionsMatcher","prismaQuery","fieldMatcher","fieldPatternMatcher"],"mappings":"iNAaaA,MAAAA,EAAsBC,IAY5B,MAAMC,sBAGHC,EACRC,WAAAA,CACEC,EACAC,GAEAC,MAAMF,EAAKG,OAAAC,OAAA,CACTC,kBAAmBC,EACnBC,aAAcC,GACXP,GAEP"}