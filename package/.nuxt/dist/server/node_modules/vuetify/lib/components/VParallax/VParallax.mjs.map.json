{"file":"VParallax.mjs","mappings":";;;;;;;;;;;;AAYA,SAAS,MAAM,KAAK;AACX,SAAA,KAAK,MAAM,KAAK,IAAI,GAAG,CAAC,IAAI,KAAK,KAAK,GAAG;AAClD;AACO,MAAM,qBAAqB,aAAa;AAAA,EAC7C,OAAO;AAAA,IACL,MAAM,CAAC,QAAQ,MAAM;AAAA,IACrB,SAAS;AAAA,EACX;AAAA,EACA,GAAG,mBAAmB;AACxB,GAAG,WAAW;AACD,MAAA,YAAY,mBAAmB;AAAA,EAC1C,MAAM;AAAA,EACN,OAAO,mBAAmB;AAAA,EAC1B,MAAM,OAAO,MAAM;AACb,QAAA;AAAA,MACF;AAAA,IAAA,IACE;AACE,UAAA;AAAA,MACJ;AAAA,MACA;AAAA,QACE,wBAAwB;AACtB,UAAA;AAAA,MACJ;AAAA,MACA;AAAA,QACE,kBAAkB;AAChB,UAAA;AAAA,MACJ,QAAQ;AAAA,QACN,WAAW;AACf,UAAM,OAAO,IAAI;AACjB,gBAAY,MAAM;;AAChB,sBAAgB,QAAQ,UAAU,SAAQ,UAAK,UAAL,mBAAY;AAAA,IAAA,CACvD;AACG,QAAA;AACJ,UAAM,gBAAgB,CAAO,QAAA;AAC3B,UAAI,KAAK;AACQ,uBAAA,gBAAgB,gBAAgB,KAAK;AACrC,uBAAA,iBAA0B,SAAA,mBAAmB,SAAW;AAC1D,qBAAA,iBAAiB,UAAU,UAAU;AAAA,UAChD,SAAS;AAAA,QAAA,CACV;AACQ,iBAAA;AAAA,MAAA,OACJ;AACQ,qBAAA,oBAAoB,UAAU,QAAQ;AAAA,MAAA;AAAA,IACrD,CACD;AAID,UAAM,eAAe,QAAQ;AAC7B,UAAM,MAAA;;AAAM,+BAAY,UAAZ,mBAAmB;AAAA,OAAQ,QAAQ;AACzC,UAAA,QAAQ,SAAS,MAAM;AAC3B,aAAO,IAAI,MAAM,OAAO,MAAM,KAAK,CAAC;AAAA,IAAA,CACrC;AACD,QAAI,QAAQ;AACZ,aAAS,WAAW;AACd,UAAA,CAAC,eAAe,MAAO;AAC3B,2BAAqB,KAAK;AAC1B,cAAQ,sBAAsB,MAAM;;AAClC,cAAM,OAAM,UAAK,UAAL,mBAAY,KAAK,cAAc,aAAa;AACxD,YAAI,CAAC,GAAI;AACT,cAAM,eAAe,wBAAwB,WAAoB,SAAA,gBAAgB,eAAe,aAAa;AAC7G,cAAM,YAAY,wBAAwB,WAAW,SAAO,UAAU,aAAa;AACnF,cAAM,MAAM,gBAAgB,MAAM,wBAAwB,MAAM;AAC1D,cAAA,SAAS,YAAY,MAAM;AAC3B,cAAA,SAAS,OAAO,SAAS,gBAAgB;AAC/C,cAAM,YAAY,OAAO,YAAY,UAAU,MAAM,KAAK;AACpD,cAAA,YAAY,KAAK,IAAI,IAAI,MAAM,SAAS,eAAe,UAAU,UAAU,MAAM;AACvF,WAAG,MAAM,YAAY,aAAa,cAAc,SAAS,aAAa,SAAS,GAAG;AAAA,MAAA,CACnF;AAAA,IAAA;AAEO,cAAA,MAAMA,YAAa,MAAM;AAAA,MACjC,SAAS,CAAC,cAAc;AAAA,QACtB,sBAAsB,eAAe;AAAA,MAAA,GACpC,MAAM,KAAK;AAAA,MACd,SAAS,MAAM;AAAA,MACf,OAAO;AAAA,MACP,SAAS;AAAA,MACT,eAAe;AAAA,MACf,UAAU;AAAA,IACZ,GAAG,KAAK,CAAC;AACT,WAAO,CAAC;AAAA,EAAA;AAEZ,CAAC;","names":["_createVNode"],"sources":["../../../../../../../../node_modules/vuetify/lib/components/VParallax/VParallax.mjs"],"sourcesContent":["import { createVNode as _createVNode } from \"vue\";\n// Styles\nimport \"./VParallax.css\";\n\n// Components\nimport { VImg } from \"../VImg/index.mjs\"; // Composables\nimport { useDisplay } from \"../../composables/index.mjs\";\nimport { makeComponentProps } from \"../../composables/component.mjs\";\nimport { useIntersectionObserver } from \"../../composables/intersectionObserver.mjs\";\nimport { useResizeObserver } from \"../../composables/resizeObserver.mjs\"; // Utilities\nimport { computed, onBeforeUnmount, ref, watch, watchEffect } from 'vue';\nimport { clamp, genericComponent, getScrollParent, propsFactory, useRender } from \"../../util/index.mjs\"; // Types\nfunction floor(val) {\n  return Math.floor(Math.abs(val)) * Math.sign(val);\n}\nexport const makeVParallaxProps = propsFactory({\n  scale: {\n    type: [Number, String],\n    default: 0.5\n  },\n  ...makeComponentProps()\n}, 'VParallax');\nexport const VParallax = genericComponent()({\n  name: 'VParallax',\n  props: makeVParallaxProps(),\n  setup(props, _ref) {\n    let {\n      slots\n    } = _ref;\n    const {\n      intersectionRef,\n      isIntersecting\n    } = useIntersectionObserver();\n    const {\n      resizeRef,\n      contentRect\n    } = useResizeObserver();\n    const {\n      height: displayHeight\n    } = useDisplay();\n    const root = ref();\n    watchEffect(() => {\n      intersectionRef.value = resizeRef.value = root.value?.$el;\n    });\n    let scrollParent;\n    watch(isIntersecting, val => {\n      if (val) {\n        scrollParent = getScrollParent(intersectionRef.value);\n        scrollParent = scrollParent === document.scrollingElement ? document : scrollParent;\n        scrollParent.addEventListener('scroll', onScroll, {\n          passive: true\n        });\n        onScroll();\n      } else {\n        scrollParent.removeEventListener('scroll', onScroll);\n      }\n    });\n    onBeforeUnmount(() => {\n      scrollParent?.removeEventListener('scroll', onScroll);\n    });\n    watch(displayHeight, onScroll);\n    watch(() => contentRect.value?.height, onScroll);\n    const scale = computed(() => {\n      return 1 - clamp(Number(props.scale));\n    });\n    let frame = -1;\n    function onScroll() {\n      if (!isIntersecting.value) return;\n      cancelAnimationFrame(frame);\n      frame = requestAnimationFrame(() => {\n        const el = (root.value?.$el).querySelector('.v-img__img');\n        if (!el) return;\n        const scrollHeight = scrollParent instanceof Document ? document.documentElement.clientHeight : scrollParent.clientHeight;\n        const scrollPos = scrollParent instanceof Document ? window.scrollY : scrollParent.scrollTop;\n        const top = intersectionRef.value.getBoundingClientRect().top + scrollPos;\n        const height = contentRect.value.height;\n        const center = top + (height - scrollHeight) / 2;\n        const translate = floor((scrollPos - center) * scale.value);\n        const sizeScale = Math.max(1, (scale.value * (scrollHeight - height) + height) / height);\n        el.style.setProperty('transform', `translateY(${translate}px) scale(${sizeScale})`);\n      });\n    }\n    useRender(() => _createVNode(VImg, {\n      \"class\": ['v-parallax', {\n        'v-parallax--active': isIntersecting.value\n      }, props.class],\n      \"style\": props.style,\n      \"ref\": root,\n      \"cover\": true,\n      \"onLoadstart\": onScroll,\n      \"onLoad\": onScroll\n    }, slots));\n    return {};\n  }\n});\n//# sourceMappingURL=VParallax.mjs.map"],"version":3}