{"version":3,"file":"virtual.mjs","sources":["../../../../../../../node_modules/vuetify/lib/composables/virtual.mjs"],"sourcesContent":["// Composables\nimport { useDisplay } from \"./display.mjs\";\nimport { useResizeObserver } from \"./resizeObserver.mjs\"; // Utilities\nimport { computed, nextTick, onScopeDispose, ref, shallowRef, watch, watchEffect } from 'vue';\nimport { clamp, debounce, IN_BROWSER, isObject, propsFactory } from \"../util/index.mjs\"; // Types\nconst UP = -1;\nconst DOWN = 1;\n\n/** Determines how large each batch of items should be */\nconst BUFFER_PX = 100;\nexport const makeVirtualProps = propsFactory({\n  itemHeight: {\n    type: [Number, String],\n    default: null\n  },\n  height: [Number, String]\n}, 'virtual');\nexport function useVirtual(props, items) {\n  const display = useDisplay();\n  const itemHeight = shallowRef(0);\n  watchEffect(() => {\n    itemHeight.value = parseFloat(props.itemHeight || 0);\n  });\n  const first = shallowRef(0);\n  const last = shallowRef(Math.ceil(\n  // Assume 16px items filling the entire screen height if\n  // not provided. This is probably incorrect but it minimises\n  // the chance of ending up with empty space at the bottom.\n  // The default value is set here to avoid poisoning getSize()\n  (parseInt(props.height) || display.height.value) / (itemHeight.value || 16)) || 1);\n  const paddingTop = shallowRef(0);\n  const paddingBottom = shallowRef(0);\n\n  /** The scrollable element */\n  const containerRef = ref();\n  /** An element marking the top of the scrollable area,\n   * used to add an offset if there's padding or other elements above the virtual list */\n  const markerRef = ref();\n  /** markerRef's offsetTop, lazily evaluated */\n  let markerOffset = 0;\n  const {\n    resizeRef,\n    contentRect\n  } = useResizeObserver();\n  watchEffect(() => {\n    resizeRef.value = containerRef.value;\n  });\n  const viewportHeight = computed(() => {\n    return containerRef.value === document.documentElement ? display.height.value : contentRect.value?.height || parseInt(props.height) || 0;\n  });\n  /** All static elements have been rendered and we have an assumed item height */\n  const hasInitialRender = computed(() => {\n    return !!(containerRef.value && markerRef.value && viewportHeight.value && itemHeight.value);\n  });\n  let sizes = Array.from({\n    length: items.value.length\n  });\n  let offsets = Array.from({\n    length: items.value.length\n  });\n  const updateTime = shallowRef(0);\n  let targetScrollIndex = -1;\n  function getSize(index) {\n    return sizes[index] || itemHeight.value;\n  }\n  const updateOffsets = debounce(() => {\n    const start = performance.now();\n    offsets[0] = 0;\n    const length = items.value.length;\n    for (let i = 1; i <= length - 1; i++) {\n      offsets[i] = (offsets[i - 1] || 0) + getSize(i - 1);\n    }\n    updateTime.value = Math.max(updateTime.value, performance.now() - start);\n  }, updateTime);\n  const unwatch = watch(hasInitialRender, v => {\n    if (!v) return;\n    // First render is complete, update offsets and visible\n    // items in case our assumed item height was incorrect\n\n    unwatch();\n    markerOffset = markerRef.value.offsetTop;\n    updateOffsets.immediate();\n    calculateVisibleItems();\n    if (!~targetScrollIndex) return;\n    nextTick(() => {\n      IN_BROWSER && window.requestAnimationFrame(() => {\n        scrollToIndex(targetScrollIndex);\n        targetScrollIndex = -1;\n      });\n    });\n  });\n  onScopeDispose(() => {\n    updateOffsets.clear();\n  });\n  function handleItemResize(index, height) {\n    const prevHeight = sizes[index];\n    const prevMinHeight = itemHeight.value;\n    itemHeight.value = prevMinHeight ? Math.min(itemHeight.value, height) : height;\n    if (prevHeight !== height || prevMinHeight !== itemHeight.value) {\n      sizes[index] = height;\n      updateOffsets();\n    }\n  }\n  function calculateOffset(index) {\n    index = clamp(index, 0, items.value.length - 1);\n    return offsets[index] || 0;\n  }\n  function calculateIndex(scrollTop) {\n    return binaryClosest(offsets, scrollTop);\n  }\n  let lastScrollTop = 0;\n  let scrollVelocity = 0;\n  let lastScrollTime = 0;\n  watch(viewportHeight, (val, oldVal) => {\n    if (oldVal) {\n      calculateVisibleItems();\n      if (val < oldVal) {\n        requestAnimationFrame(() => {\n          scrollVelocity = 0;\n          calculateVisibleItems();\n        });\n      }\n    }\n  });\n  let scrollTimeout = -1;\n  function handleScroll() {\n    if (!containerRef.value || !markerRef.value) return;\n    const scrollTop = containerRef.value.scrollTop;\n    const scrollTime = performance.now();\n    const scrollDeltaT = scrollTime - lastScrollTime;\n    if (scrollDeltaT > 500) {\n      scrollVelocity = Math.sign(scrollTop - lastScrollTop);\n\n      // Not super important, only update at the\n      // start of a scroll sequence to avoid reflows\n      markerOffset = markerRef.value.offsetTop;\n    } else {\n      scrollVelocity = scrollTop - lastScrollTop;\n    }\n    lastScrollTop = scrollTop;\n    lastScrollTime = scrollTime;\n    window.clearTimeout(scrollTimeout);\n    scrollTimeout = window.setTimeout(handleScrollend, 500);\n    calculateVisibleItems();\n  }\n  function handleScrollend() {\n    if (!containerRef.value || !markerRef.value) return;\n    scrollVelocity = 0;\n    lastScrollTime = 0;\n    window.clearTimeout(scrollTimeout);\n    calculateVisibleItems();\n  }\n  let raf = -1;\n  function calculateVisibleItems() {\n    cancelAnimationFrame(raf);\n    raf = requestAnimationFrame(_calculateVisibleItems);\n  }\n  function _calculateVisibleItems() {\n    if (!containerRef.value || !viewportHeight.value) return;\n    const scrollTop = lastScrollTop - markerOffset;\n    const direction = Math.sign(scrollVelocity);\n    const startPx = Math.max(0, scrollTop - BUFFER_PX);\n    const start = clamp(calculateIndex(startPx), 0, items.value.length);\n    const endPx = scrollTop + viewportHeight.value + BUFFER_PX;\n    const end = clamp(calculateIndex(endPx) + 1, start + 1, items.value.length);\n    if (\n    // Only update the side we're scrolling towards,\n    // the other side will be updated incidentally\n    (direction !== UP || start < first.value) && (direction !== DOWN || end > last.value)) {\n      const topOverflow = calculateOffset(first.value) - calculateOffset(start);\n      const bottomOverflow = calculateOffset(end) - calculateOffset(last.value);\n      const bufferOverflow = Math.max(topOverflow, bottomOverflow);\n      if (bufferOverflow > BUFFER_PX) {\n        first.value = start;\n        last.value = end;\n      } else {\n        // Only update the side that's reached its limit if there's still buffer left\n        if (start <= 0) first.value = start;\n        if (end >= items.value.length) last.value = end;\n      }\n    }\n    paddingTop.value = calculateOffset(first.value);\n    paddingBottom.value = calculateOffset(items.value.length) - calculateOffset(last.value);\n  }\n  function scrollToIndex(index) {\n    const offset = calculateOffset(index);\n    if (!containerRef.value || index && !offset) {\n      targetScrollIndex = index;\n    } else {\n      containerRef.value.scrollTop = offset;\n    }\n  }\n  const computedItems = computed(() => {\n    return items.value.slice(first.value, last.value).map((item, index) => ({\n      raw: item,\n      index: index + first.value,\n      key: isObject(item) && 'value' in item ? item.value : index + first.value\n    }));\n  });\n  watch(items, () => {\n    sizes = Array.from({\n      length: items.value.length\n    });\n    offsets = Array.from({\n      length: items.value.length\n    });\n    updateOffsets.immediate();\n    calculateVisibleItems();\n  }, {\n    deep: true\n  });\n  return {\n    calculateVisibleItems,\n    containerRef,\n    markerRef,\n    computedItems,\n    paddingTop,\n    paddingBottom,\n    scrollToIndex,\n    handleScroll,\n    handleScrollend,\n    handleItemResize\n  };\n}\n\n// https://gist.github.com/robertleeplummerjr/1cc657191d34ecd0a324\nfunction binaryClosest(arr, val) {\n  let high = arr.length - 1;\n  let low = 0;\n  let mid = 0;\n  let item = null;\n  let target = -1;\n  if (arr[high] < val) {\n    return high;\n  }\n  while (low <= high) {\n    mid = low + high >> 1;\n    item = arr[mid];\n    if (item > val) {\n      high = mid - 1;\n    } else if (item < val) {\n      target = mid;\n      low = mid + 1;\n    } else if (item === val) {\n      return mid;\n    } else {\n      return low;\n    }\n  }\n  return target;\n}\n//# sourceMappingURL=virtual.mjs.map"],"names":[],"mappings":"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","x_google_ignoreList":[0]}